const fs = require('fs')
const webpack = require('webpack')
const WebpackDevServer = require('webpack-dev-server')
const chalk = require('chalk')
const paths = require('@automs/tools/libs/paths')
const checkRequiredFiles = require('@automs/tools/libs/checkRequiredFiles')
const {
  choosePort,
  createCompiler,
  prepareProxy,
  prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils')
const { checkBrowsers } = require('react-dev-utils/browsersHelper')
const clearConsole = require('react-dev-utils/clearConsole')
const openBrowser = require('react-dev-utils/openBrowser')
const createDevServerConfig = require('react-scripts/config/webpackDevServer.config')
const webpackConfig = require('./config')

const webpackDevServer = async () => {
  if (!checkRequiredFiles([paths.appDevHtml, paths.appIndexJs])) {
    throw new Error('缺少打包需要的入口文件')
  }

  const isInteractive = process.stdout.isTTY
  const useTypeScript = fs.existsSync(paths.appTsConfig)
  const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === 'true'
  const useYarn = fs.existsSync(paths.yarnLockFile)
  const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000
  const HOST = '0.0.0.0'

  process.env.BABEL_ENV = 'development'
  process.env.NODE_ENV = 'development'
  process.env.REACT_APP_PACKAGE = 'dev'

  process.on('unhandledRejection', err => {
    throw err
  })

  checkBrowsers(paths.appPath, isInteractive)
    .then(() => {
      return choosePort(HOST, DEFAULT_PORT)
    })
    .then(port => {
      if (port === null) {
        return
      }

      const config = webpackConfig('dev')
      const protocol = process.env.HTTPS === 'true' ? 'https' : 'http'
      const appName = require(paths.appPackageJson).name
      const urls = prepareUrls(protocol, HOST, port, '/')

      const devSocket = {
        warnings: warnings => devServer.sockWrite(devServer.sockets, 'warnings', warnings),
        errors: errors => devServer.sockWrite(devServer.sockets, 'errors', errors),
      }

      // Create a webpack compiler that is configured with custom messages.
      const compiler = createCompiler({
        appName,
        config,
        devSocket,
        urls,
        useYarn,
        useTypeScript,
        tscCompileOnError,
        webpack,
      })

      // Load proxy config
      const proxySetting = require(paths.appPackageJson).proxy
      const proxyConfig = prepareProxy(proxySetting, paths.appPublic, '/')

      // Serve webpack assets generated by the compiler over a web server.
      const serverConfig = createDevServerConfig(proxyConfig, urls.lanUrlForConfig)
      serverConfig.contentBasePublicPath = '/'
      serverConfig.publicPath = ''
      const devServer = new WebpackDevServer(compiler, serverConfig)

      // Launch WebpackDevServer.
      devServer.listen(port, HOST, err => {
        if (err) {
          return console.log(err)
        }
        if (isInteractive) {
          clearConsole()
        }

        console.log(chalk.cyan('Starting the development server...\n'))
        openBrowser(urls.localUrlForBrowser)
      })

      const sigs = [('SIGINT', 'SIGTERM')]

      sigs.forEach(sig => {
        process.on(sig, () => {
          devServer.close()
          process.exit()
        })
      })

      if (process.env.CI !== 'true') {
        // Gracefully exit when stdin ends
        process.stdin.on('end', function () {
          devServer.close()
          process.exit()
        })
      }
    })
    .catch(err => {
      if (err && err.message) {
        console.log(err.message)
      }
      process.exit(1)
    })
}

module.exports = webpackDevServer
